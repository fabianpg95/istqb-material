{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction This guide purpose\u2019s is to provide the tester some information and guidance about ISTQB Foundation Level.","title":"Introduction"},{"location":"#introduction","text":"This guide purpose\u2019s is to provide the tester some information and guidance about ISTQB Foundation Level.","title":"Introduction"},{"location":"istqb_material/test_ref/","text":"External resources: Udemy ISTQB Foundation Level (2021) ISTQB Official Website ISTQB Foundation Level Agile Tester","title":"References"},{"location":"istqb_material/test_ref/#external-resources","text":"Udemy ISTQB Foundation Level (2021) ISTQB Official Website ISTQB Foundation Level Agile Tester","title":"External resources:"},{"location":"istqb_material/fundamentals/defect_report/","text":"What is a defect report? Documentation of the occurrence, nature, and status of a defect . If we use an example like Facebook, these would be the priorities. Bug priority: Critical: Login isn\u2019t working-Application crashes in Home page \u2013 Wrong cart value High: Login page responds slowly \u2013 User is not able to add profile image Medium: Some pages have poor performance- Portrait mode isn\u2019t working correctly Low: Spelling mistakes \u2013 Image misalignment Example of a defect report:","title":"Defect report"},{"location":"istqb_material/fundamentals/defect_report/#what-is-a-defect-report","text":"Documentation of the occurrence, nature, and status of a defect . If we use an example like Facebook, these would be the priorities.","title":"What is a defect report?"},{"location":"istqb_material/fundamentals/defect_report/#bug-priority","text":"Critical: Login isn\u2019t working-Application crashes in Home page \u2013 Wrong cart value High: Login page responds slowly \u2013 User is not able to add profile image Medium: Some pages have poor performance- Portrait mode isn\u2019t working correctly Low: Spelling mistakes \u2013 Image misalignment","title":"Bug priority:"},{"location":"istqb_material/fundamentals/defect_report/#example-of-a-defect-report","text":"","title":"Example of a defect report:"},{"location":"istqb_material/fundamentals/defect_types/","text":"Types 1-Functional: Forgot password functionality isn\u2019t working. 2-Visual (UI): 3-Content: 4-Performance: Videos take too much time to play. 5-Suggestion: The font of the placeholder should be bigger Status","title":"Defect types"},{"location":"istqb_material/fundamentals/defect_types/#types","text":"","title":"Types"},{"location":"istqb_material/fundamentals/defect_types/#1-functional","text":"Forgot password functionality isn\u2019t working.","title":"1-Functional:"},{"location":"istqb_material/fundamentals/defect_types/#2-visual-ui","text":"","title":"2-Visual (UI):"},{"location":"istqb_material/fundamentals/defect_types/#3-content","text":"","title":"3-Content:"},{"location":"istqb_material/fundamentals/defect_types/#4-performance","text":"Videos take too much time to play.","title":"4-Performance:"},{"location":"istqb_material/fundamentals/defect_types/#5-suggestion","text":"The font of the placeholder should be bigger Status","title":"5-Suggestion:"},{"location":"istqb_material/fundamentals/test_intro/","text":"Definition of 'testing': \"Software testing is a way to asses the quality of the software and to reduce the risk of software failures in operation.\" Note ISTQB definition: \"Testing is the process consisting of all lifecycle activities (static and dynamic) concerned with planning preparation and evaluation pf a component system and related work products to determine that they satisfy specified requirements for purpose and to detect defects.\" A common misconception of testing is that it only consists of running tests, executing the software and checking the results. However, test activities are before and after test execution. Example: Planning and control Choose test conditions Designing test cases Evaluation of completion criteria Reporting the testing progress and results Typical testing objectives Verify requirements Prevent defects Find defects and failures Gain confidence in system Reduce the level of risk Providing information for decision making Compliance 'Errors', 'defects' and 'failures' Software systems are increasingly complex, often systems are connected to many other systems. Development of these complex systems requires a great deal of time, skill and effort, and during this process, human beings can make errors or mistakes . Errors can lead to the introduction of a defect (fault or bug) in the software code or in any other work product. Errors may occur due to many reasons such as: Time pressure. Humans are not perfect, so always there is a risk to make errors or mistakes. Skills not match with the architecture or technologies Complexity of system Changing technologies If a Defect has been introduced into the code after the code is executed it could cause a failure . (A failure occurs within the system). Failures may also caused by environmental conditions Diagram: gst Root Cause Analysis The root causes of defects are the earliest actions or conditions that contributed to creating the defects. Typical RCA include: Unclear requirement Missing requirement Wrong requirement Code logic error Invalid data","title":"Introduction"},{"location":"istqb_material/fundamentals/test_intro/#definition-of-testing","text":"\"Software testing is a way to asses the quality of the software and to reduce the risk of software failures in operation.\" Note ISTQB definition: \"Testing is the process consisting of all lifecycle activities (static and dynamic) concerned with planning preparation and evaluation pf a component system and related work products to determine that they satisfy specified requirements for purpose and to detect defects.\" A common misconception of testing is that it only consists of running tests, executing the software and checking the results. However, test activities are before and after test execution. Example: Planning and control Choose test conditions Designing test cases Evaluation of completion criteria Reporting the testing progress and results","title":"Definition of 'testing':"},{"location":"istqb_material/fundamentals/test_intro/#typical-testing-objectives","text":"Verify requirements Prevent defects Find defects and failures Gain confidence in system Reduce the level of risk Providing information for decision making Compliance","title":"Typical testing objectives"},{"location":"istqb_material/fundamentals/test_intro/#errors-defects-and-failures","text":"Software systems are increasingly complex, often systems are connected to many other systems. Development of these complex systems requires a great deal of time, skill and effort, and during this process, human beings can make errors or mistakes . Errors can lead to the introduction of a defect (fault or bug) in the software code or in any other work product. Errors may occur due to many reasons such as: Time pressure. Humans are not perfect, so always there is a risk to make errors or mistakes. Skills not match with the architecture or technologies Complexity of system Changing technologies If a Defect has been introduced into the code after the code is executed it could cause a failure . (A failure occurs within the system). Failures may also caused by environmental conditions","title":"'Errors', 'defects' and 'failures'"},{"location":"istqb_material/fundamentals/test_intro/#diagram","text":"gst","title":"Diagram:"},{"location":"istqb_material/fundamentals/test_intro/#root-cause-analysis","text":"The root causes of defects are the earliest actions or conditions that contributed to creating the defects. Typical RCA include: Unclear requirement Missing requirement Wrong requirement Code logic error Invalid data","title":"Root Cause Analysis"},{"location":"istqb_material/fundamentals/test_principles/","text":"Over the last 50 years, there have been number of testing principles that offer general guidelines but the ISTQB Syllabus covers 7 principles: Principle 1: Testing shows presence of defects, not their absence. Testing can show that defects are present, but it cannot prove that no defects are remaining. Note Even when no defects are found during testing, it can\u00b4t be proved that software is defect-free. Always exist risks. Principle 2: Exhaustive testing is impossible Testing everything (all combinations of inputs and preconditions) is not possible, except for trivial cases. Rather than attempting to test exhaustively, the effort should be focus on risks analysis, test techniques and priorities. Note It is not possible to test all possible combinations of data input in most of the circunstances. Exhaustive testing is a test approach in which all possible data combinations are used, including the implicit in the state of the software, so is not feasible. Principle 3: Early testing saves time and money The following diagram shows that the relative cost of fixing the defects increase with each project phase. Principle 4: Defects cluster together Experience shows that in general, a small number of software modules contains most of the defects discovered during pre-release testing or are responsible for most of the operational failures. Defects are clustered in modules that are: More complex Larger More prone to changes Have been worked on by many different developers over time Note 80% of defects come from 20% of the modules (Pareto principle applied to software testing). Principle 5: Beware of Pesticide paradox If the same tests are repeated over and over again, eventually these tests no longer find any new defects. If the same test cases fail to find any new defects, running the same test cases, again and again, will eventually leave the tester with a false sense of security.(The same apply for regression tests) Recommendations: Review test cases regularly Add more relevant new test cases to exercise different parts of the software and remove the test cases which are not required. Consider the value of running tests in each regression run. Make sure there is a value-add from the effort. Principle 6: Testing is context dependent Testing is done differently in different contexts. For example, safety-critical software is tested differently from e-commerce software. Recommendations: Same set of testing activities are not applicable for all applications. Testing is done for different applications. Risk must be considered in determining the type of testing that is needed. Principle 7: Absense-of-error fallacy It is a mistake to expect that just finding and fixing a large number of defects will ensure the success of a system.","title":"7 test principles"},{"location":"istqb_material/fundamentals/test_principles/#principle-1-testing-shows-presence-of-defects-not-their-absence","text":"Testing can show that defects are present, but it cannot prove that no defects are remaining. Note Even when no defects are found during testing, it can\u00b4t be proved that software is defect-free. Always exist risks.","title":"Principle 1: Testing shows presence of defects, not their absence."},{"location":"istqb_material/fundamentals/test_principles/#principle-2-exhaustive-testing-is-impossible","text":"Testing everything (all combinations of inputs and preconditions) is not possible, except for trivial cases. Rather than attempting to test exhaustively, the effort should be focus on risks analysis, test techniques and priorities. Note It is not possible to test all possible combinations of data input in most of the circunstances. Exhaustive testing is a test approach in which all possible data combinations are used, including the implicit in the state of the software, so is not feasible.","title":"Principle 2: Exhaustive testing is impossible"},{"location":"istqb_material/fundamentals/test_principles/#principle-3-early-testing-saves-time-and-money","text":"The following diagram shows that the relative cost of fixing the defects increase with each project phase.","title":"Principle 3: Early testing saves time and money"},{"location":"istqb_material/fundamentals/test_principles/#principle-4-defects-cluster-together","text":"Experience shows that in general, a small number of software modules contains most of the defects discovered during pre-release testing or are responsible for most of the operational failures. Defects are clustered in modules that are: More complex Larger More prone to changes Have been worked on by many different developers over time Note 80% of defects come from 20% of the modules (Pareto principle applied to software testing).","title":"Principle 4: Defects cluster together"},{"location":"istqb_material/fundamentals/test_principles/#principle-5-beware-of-pesticide-paradox","text":"If the same tests are repeated over and over again, eventually these tests no longer find any new defects. If the same test cases fail to find any new defects, running the same test cases, again and again, will eventually leave the tester with a false sense of security.(The same apply for regression tests) Recommendations: Review test cases regularly Add more relevant new test cases to exercise different parts of the software and remove the test cases which are not required. Consider the value of running tests in each regression run. Make sure there is a value-add from the effort.","title":"Principle 5: Beware of Pesticide paradox"},{"location":"istqb_material/fundamentals/test_principles/#principle-6-testing-is-context-dependent","text":"Testing is done differently in different contexts. For example, safety-critical software is tested differently from e-commerce software. Recommendations: Same set of testing activities are not applicable for all applications. Testing is done for different applications. Risk must be considered in determining the type of testing that is needed.","title":"Principle 6: Testing is context dependent"},{"location":"istqb_material/fundamentals/test_principles/#principle-7-absense-of-error-fallacy","text":"It is a mistake to expect that just finding and fixing a large number of defects will ensure the success of a system.","title":"Principle 7: Absense-of-error fallacy"},{"location":"istqb_material/fundamentals/test_process/","text":"(ISO /IEC/IEEE 29119 -2) provides more information about test processes. Considerations Contextual factor that influence the test process for an organization include, but not are limited to: SDLC model and project methodologies being used. Test levels and test types being considered. Product and project risks Business domain Operational constraints: Budget and resources Timescales Complexity Organizational policies and standards Regulatory contracts Test activities and tasks","title":"Test process"},{"location":"istqb_material/fundamentals/test_process/#considerations","text":"Contextual factor that influence the test process for an organization include, but not are limited to: SDLC model and project methodologies being used. Test levels and test types being considered. Product and project risks Business domain Operational constraints: Budget and resources Timescales Complexity Organizational policies and standards Regulatory contracts","title":"Considerations"},{"location":"istqb_material/fundamentals/test_process/#test-activities-and-tasks","text":"","title":"Test activities and tasks"},{"location":"istqb_material/software_lifecycle/dev_models/","text":"Software Development Life Cycle (SDLC A SDLC describes the type of activities performed at each stage in a software development project. There are a number of different software development lifecycle models, each of which requires different approaches to testing. Software Development Process Models. ISTQB Syllabus divide the models into 3 categories: 1.- Traditional (optional, and default for Project management) 2.- Sequential 3.- Iterative and Incremental Traditional SDLC The traditional SDLC is a model used in project management that defines the stages include in an information system development project, from an initial feasibility study to the maintenance of the completed application. Sequential Development model This model describes the software development process as a linear, sequential flow of activities. That means that any phase in the development process should only begin when the previous phase is completed. Examples: Waterfall model V-model Explanation: The activities on the left-hand side of the V-model focuses on work-product creation for elaborating the initial requirements and then providing more technical detail for the development. ( Static testing ) The activities for the right-hand focuses on the testing activities. ( Dynamic testing ) Verification helps to ensure that the product is built in the right way.( the process ) Validation checks that the right product is being built. Iterative and incremental model Works on smaller incremental developments. ( iterations ) Good practices for Software Development and Software Testing: For every development activity, there is a corresponding testing activity. Each test level has test objectives specific to that level The analysis and design of tests for a given test level should begin during the corresponding development activity. Testers participate in discussions to define and refine requirements and design.","title":"Models"},{"location":"istqb_material/software_lifecycle/dev_models/#software-development-life-cycle-sdlc","text":"A SDLC describes the type of activities performed at each stage in a software development project. There are a number of different software development lifecycle models, each of which requires different approaches to testing.","title":"Software Development Life Cycle (SDLC"},{"location":"istqb_material/software_lifecycle/dev_models/#software-development-process-models","text":"ISTQB Syllabus divide the models into 3 categories: 1.- Traditional (optional, and default for Project management) 2.- Sequential 3.- Iterative and Incremental","title":"Software Development Process Models."},{"location":"istqb_material/software_lifecycle/dev_models/#traditional-sdlc","text":"The traditional SDLC is a model used in project management that defines the stages include in an information system development project, from an initial feasibility study to the maintenance of the completed application.","title":"Traditional SDLC"},{"location":"istqb_material/software_lifecycle/dev_models/#sequential-development-model","text":"This model describes the software development process as a linear, sequential flow of activities. That means that any phase in the development process should only begin when the previous phase is completed. Examples: Waterfall model V-model Explanation: The activities on the left-hand side of the V-model focuses on work-product creation for elaborating the initial requirements and then providing more technical detail for the development. ( Static testing ) The activities for the right-hand focuses on the testing activities. ( Dynamic testing ) Verification helps to ensure that the product is built in the right way.( the process ) Validation checks that the right product is being built.","title":"Sequential Development model"},{"location":"istqb_material/software_lifecycle/dev_models/#iterative-and-incremental-model","text":"Works on smaller incremental developments. ( iterations )","title":"Iterative and incremental model"},{"location":"istqb_material/software_lifecycle/dev_models/#good-practices-for-software-development-and-software-testing","text":"For every development activity, there is a corresponding testing activity. Each test level has test objectives specific to that level The analysis and design of tests for a given test level should begin during the corresponding development activity. Testers participate in discussions to define and refine requirements and design.","title":"Good practices for Software Development and Software Testing:"},{"location":"istqb_material/software_lifecycle/test_levels/","text":"For every test level, a suitable test environment is required, for example for Acceptance is Production and for Unit tests is the development environment. Unit/component testing Focuses on components that are separately testable. Typical test basis Detailed design Code Data model Component specification Typical defects and failures: Incorrect functionality Data flow problems Incorrect code and logic Typical test objects: Components, units or modules Code and data structures Classes Database modules Summary: Performed by developers who have coded the component. For agile teams, Test Driven Development (TDD) is the most common practice. Developed and tested using development environment. Integration testing Focuses on the interaction between components or systems. This stage should be focuses on the communication between the modules, not the functionality of the individual modules because that part should be covered in unit tests. Typical test basis Architecture at component or system level Sequence diagrams Interface and communication protocol specifications Use cases Workflows Typical defects Interfaces mismatch Failures in communication between components Incorrect timing, sequencing or interface calls Typical test objects Sub-systems Database implementation Infrastructure Interfaces API\u00b4s Microservices System testing Typical test basis Use cases Epics and user stories Models of system behavior State diagrams System and user manuals Typical defects Incorrect calculations Incorrect or unexpected system functional or non-functional behavior Failure of the system to work properly Failure of the system to work as described in system and user manual Typical test objects Applications Hardware/Software systems O.S System Under Test (SUT) Acceptance testing Then purpose of acceptance testing is to validate the system is fit for purpose. Typical test basis Business processes User or business requirements Risk analysis reports Installation procedures Legal contracts or standards Typical defects System workflows don\u00b4t meet business or user requirements Business rules are not implemented correctly Non-functional failures such as security vulnerabilities, performance efficiency or improper operations. Typical test objects System Under Test Forms Reports Recovery systems and hot sites Existing and converted production data Alpha and Beta testing: Alpha Is performed at the developing organization\u00b4s site, not by the development team, but by potencial or existing customer, operators or independent test team. Beta Is performed by potential or existingn customer or operators at their own locations. Note Beta testing may come after Alpha testing or may occur without any preceding alpha testing.","title":"Test levels"},{"location":"istqb_material/software_lifecycle/test_levels/#unitcomponent-testing","text":"Focuses on components that are separately testable.","title":"Unit/component testing"},{"location":"istqb_material/software_lifecycle/test_levels/#typical-test-basis","text":"Detailed design Code Data model Component specification","title":"Typical test basis"},{"location":"istqb_material/software_lifecycle/test_levels/#typical-defects-and-failures","text":"Incorrect functionality Data flow problems Incorrect code and logic","title":"Typical defects and failures:"},{"location":"istqb_material/software_lifecycle/test_levels/#typical-test-objects","text":"Components, units or modules Code and data structures Classes Database modules","title":"Typical test objects:"},{"location":"istqb_material/software_lifecycle/test_levels/#summary","text":"Performed by developers who have coded the component. For agile teams, Test Driven Development (TDD) is the most common practice. Developed and tested using development environment.","title":"Summary:"},{"location":"istqb_material/software_lifecycle/test_levels/#integration-testing","text":"Focuses on the interaction between components or systems. This stage should be focuses on the communication between the modules, not the functionality of the individual modules because that part should be covered in unit tests.","title":"Integration testing"},{"location":"istqb_material/software_lifecycle/test_levels/#typical-test-basis_1","text":"Architecture at component or system level Sequence diagrams Interface and communication protocol specifications Use cases Workflows","title":"Typical test basis"},{"location":"istqb_material/software_lifecycle/test_levels/#typical-defects","text":"Interfaces mismatch Failures in communication between components Incorrect timing, sequencing or interface calls","title":"Typical defects"},{"location":"istqb_material/software_lifecycle/test_levels/#typical-test-objects_1","text":"Sub-systems Database implementation Infrastructure Interfaces API\u00b4s Microservices","title":"Typical test objects"},{"location":"istqb_material/software_lifecycle/test_levels/#system-testing","text":"","title":"System testing"},{"location":"istqb_material/software_lifecycle/test_levels/#typical-test-basis_2","text":"Use cases Epics and user stories Models of system behavior State diagrams System and user manuals","title":"Typical test basis"},{"location":"istqb_material/software_lifecycle/test_levels/#typical-defects_1","text":"Incorrect calculations Incorrect or unexpected system functional or non-functional behavior Failure of the system to work properly Failure of the system to work as described in system and user manual","title":"Typical defects"},{"location":"istqb_material/software_lifecycle/test_levels/#typical-test-objects_2","text":"Applications Hardware/Software systems O.S System Under Test (SUT)","title":"Typical test objects"},{"location":"istqb_material/software_lifecycle/test_levels/#acceptance-testing","text":"Then purpose of acceptance testing is to validate the system is fit for purpose.","title":"Acceptance testing"},{"location":"istqb_material/software_lifecycle/test_levels/#typical-test-basis_3","text":"Business processes User or business requirements Risk analysis reports Installation procedures Legal contracts or standards","title":"Typical test basis"},{"location":"istqb_material/software_lifecycle/test_levels/#typical-defects_2","text":"System workflows don\u00b4t meet business or user requirements Business rules are not implemented correctly Non-functional failures such as security vulnerabilities, performance efficiency or improper operations.","title":"Typical defects"},{"location":"istqb_material/software_lifecycle/test_levels/#typical-test-objects_3","text":"System Under Test Forms Reports Recovery systems and hot sites Existing and converted production data","title":"Typical test objects"},{"location":"istqb_material/software_lifecycle/test_levels/#alpha-and-beta-testing","text":"Alpha Is performed at the developing organization\u00b4s site, not by the development team, but by potencial or existing customer, operators or independent test team. Beta Is performed by potential or existingn customer or operators at their own locations. Note Beta testing may come after Alpha testing or may occur without any preceding alpha testing.","title":"Alpha and Beta testing:"},{"location":"istqb_material/static_dynamic_test/dif_stat_dyn/","text":"","title":"Static vs Dynamic"},{"location":"istqb_material/static_dynamic_test/dynamic_test/","text":"Is the type of testing that validates the functionality of an application when the code is executed Main features Dynamic testing involves both functional and non-functional testing. It is executed during the validation stage of the software testing. Is done by executing the code. Dynamic Testing Techniques: Functional Testing: Unit Testing Integration Testing System Testing Non-functional Testing: Security testing Performance testing Recovery testing","title":"Dynamic test"},{"location":"istqb_material/static_dynamic_test/dynamic_test/#main-features","text":"Dynamic testing involves both functional and non-functional testing. It is executed during the validation stage of the software testing. Is done by executing the code.","title":"Main features"},{"location":"istqb_material/static_dynamic_test/dynamic_test/#dynamic-testing-techniques","text":"","title":"Dynamic Testing Techniques:"},{"location":"istqb_material/static_dynamic_test/dynamic_test/#functional-testing","text":"Unit Testing Integration Testing System Testing","title":"Functional Testing:"},{"location":"istqb_material/static_dynamic_test/dynamic_test/#non-functional-testing","text":"Security testing Performance testing Recovery testing","title":"Non-functional Testing:"},{"location":"istqb_material/static_dynamic_test/static_test/","text":"Is a software testing method that involves examination of program\u00b4s code and its associated documentation but does not require the program to be executed. Main features It is a stage of white box testing. Can also be referred as dry-run testing. Is performed during the verification process. Static Testing Techniques: Can be used to 'test' any form of document including source code , design documents and models , functional specifications and requirements . Review: Typically used to find and eliminate errors or ambiguities in documents such as requirements, design, test cases, etc. Static analysis: The code written by developers are analysed (usually by tools) for structural defects that may lead to defects. Tools Raxis RIPS Technologies Code Compare","title":"Static test"},{"location":"istqb_material/static_dynamic_test/static_test/#main-features","text":"It is a stage of white box testing. Can also be referred as dry-run testing. Is performed during the verification process.","title":"Main features"},{"location":"istqb_material/static_dynamic_test/static_test/#static-testing-techniques","text":"Can be used to 'test' any form of document including source code , design documents and models , functional specifications and requirements .","title":"Static Testing Techniques:"},{"location":"istqb_material/static_dynamic_test/static_test/#review","text":"Typically used to find and eliminate errors or ambiguities in documents such as requirements, design, test cases, etc.","title":"Review:"},{"location":"istqb_material/static_dynamic_test/static_test/#static-analysis","text":"The code written by developers are analysed (usually by tools) for structural defects that may lead to defects.","title":"Static analysis:"},{"location":"istqb_material/static_dynamic_test/static_test/#tools","text":"Raxis RIPS Technologies Code Compare","title":"Tools"},{"location":"istqb_material/test_techniques/experience_based/exp_based_tech/","text":"In experience-based techniques, people\u2019s knowledge, skills and background are of prime importance to the test conditions and test cases. Different types of experience-based testing techniques There are mainly two techniques under this category; Error guessing Is a simple technique that takes advantage of a tester\u2019s skill, intuition and experience with similar applications to identify special tests that formal Black Box techniques could not identify. Examples: Divide by zero Null pointer exception Invalid parameters Uploading files exceeding maximum limits. Exploratory testing","title":"Exp Based Technique"},{"location":"istqb_material/test_techniques/experience_based/exp_based_tech/#different-types-of-experience-based-testing-techniques","text":"There are mainly two techniques under this category;","title":"Different types of experience-based testing techniques"},{"location":"istqb_material/test_techniques/experience_based/exp_based_tech/#error-guessing","text":"Is a simple technique that takes advantage of a tester\u2019s skill, intuition and experience with similar applications to identify special tests that formal Black Box techniques could not identify. Examples: Divide by zero Null pointer exception Invalid parameters Uploading files exceeding maximum limits.","title":"Error guessing"},{"location":"istqb_material/test_techniques/experience_based/exp_based_tech/#exploratory-testing","text":"","title":"Exploratory testing"},{"location":"istqb_material/test_techniques/white_box/dec_test_cov/","text":"","title":"Decision Test Coverage"},{"location":"istqb_material/test_techniques/white_box/sta_test_cov/","text":"","title":"Sta test cov"},{"location":"istqb_material/test_techniques/white_box/val_st_dec_test/","text":"","title":"Value State Decision"},{"location":"istqb_material/test_types/black_box/","text":"Testing without knowing the internal structure of the system. Types of Black box testing Black box testing can be applied to three main types of tests: functional , non-functional , and regression testing . Functional testing It can check if it\u00b4s possible log in using correct credentials or not if are wrong. Non functional testing It can check for security vulnerabilities. Performance under expected loads Usable and easy to understand for users Compatible with relevant devices, screen sizes, browsers or O.S. Regression testing Regression can be applied for functional and non-functional. Black box can check if a new version of software load slower as an example. Black Box testing techniques: Equivalence Partitioning Boundary Value Analysis Decision Table Testing Error guessing","title":"Black Box"},{"location":"istqb_material/test_types/black_box/#types-of-black-box-testing","text":"Black box testing can be applied to three main types of tests: functional , non-functional , and regression testing .","title":"Types of Black box testing"},{"location":"istqb_material/test_types/black_box/#functional-testing","text":"It can check if it\u00b4s possible log in using correct credentials or not if are wrong.","title":"Functional testing"},{"location":"istqb_material/test_types/black_box/#non-functional-testing","text":"It can check for security vulnerabilities. Performance under expected loads Usable and easy to understand for users Compatible with relevant devices, screen sizes, browsers or O.S.","title":"Non functional testing"},{"location":"istqb_material/test_types/black_box/#regression-testing","text":"Regression can be applied for functional and non-functional. Black box can check if a new version of software load slower as an example.","title":"Regression testing"},{"location":"istqb_material/test_types/black_box/#black-box-testing-techniques","text":"Equivalence Partitioning Boundary Value Analysis Decision Table Testing Error guessing","title":"Black Box testing techniques:"},{"location":"istqb_material/test_types/change_rel/","text":"Regression testing is a type of testing aimed at checking changes made in an application or the environment (fixing a defect, merging code, migrating to another operating system, database, web server or application server) to confirm the fact that the existing functionality is working as before. Confirmation testing Confirms that the original defect has been successfully fixed. Regression testing Confirms that the changes have not caused any side-defects. Tools Selenium Katalon Studio AdventNet QEngine Regression Tester vTest Watir actiWate","title":"Change related test"},{"location":"istqb_material/test_types/change_rel/#confirmation-testing","text":"Confirms that the original defect has been successfully fixed.","title":"Confirmation testing"},{"location":"istqb_material/test_types/change_rel/#regression-testing","text":"Confirms that the changes have not caused any side-defects.","title":"Regression testing"},{"location":"istqb_material/test_types/change_rel/#tools","text":"Selenium Katalon Studio AdventNet QEngine Regression Tester vTest Watir actiWate","title":"Tools"},{"location":"istqb_material/test_types/func_test/","text":"Is conducted to verify that functions of a system are working as specified. There are a variety of functional testing strategies, and the best way to ensure functional test coverage is a mix of manual and automated testing. The most common functional testing strategies are black-box testing methods wherein the tester does not need to review the internal source code, but validates functionality by testing various input combinations. Main features Testing what the system should do Usually answered with (Yes/No) Functional tests should be performed at all test levels Can run manual and automated tests Login example Navigate to login page In the \u2019email\u2019 field, enter the email address of the registered user Click the \u2018Next\u2019 button Enter the password of the registered * user Click \u2018Sign In\u2019 If success, go to next page If not, throw error message and go back to login page Tools Selenium Cypress MicroFocus Katalon","title":"Functional test"},{"location":"istqb_material/test_types/func_test/#main-features","text":"Testing what the system should do Usually answered with (Yes/No) Functional tests should be performed at all test levels Can run manual and automated tests","title":"Main features"},{"location":"istqb_material/test_types/func_test/#login-example","text":"Navigate to login page In the \u2019email\u2019 field, enter the email address of the registered user Click the \u2018Next\u2019 button Enter the password of the registered * user Click \u2018Sign In\u2019 If success, go to next page If not, throw error message and go back to login page","title":"Login example"},{"location":"istqb_material/test_types/func_test/#tools","text":"Selenium Cypress MicroFocus Katalon","title":"Tools"},{"location":"istqb_material/test_types/non_func_test/","text":"Main features Testing how the system performs Hard to answer with Yes/No Usually measured as a range or metric May be performed at all test levels Mostly for automated tests Typical questions for non-functional test: How many concurrent users can the system support? How long is the data held locally before it is archived? How long will it take for a page to download? How many transactions can occur in a period of time? What is the maximum number of transactions that can take place? Tools Jmeter Loadrunner Webserver Stress tool","title":"Non functional test"},{"location":"istqb_material/test_types/non_func_test/#main-features","text":"Testing how the system performs Hard to answer with Yes/No Usually measured as a range or metric May be performed at all test levels Mostly for automated tests","title":"Main features"},{"location":"istqb_material/test_types/non_func_test/#typical-questions-for-non-functional-test","text":"How many concurrent users can the system support? How long is the data held locally before it is archived? How long will it take for a page to download? How many transactions can occur in a period of time? What is the maximum number of transactions that can take place?","title":"Typical questions for non-functional test:"},{"location":"istqb_material/test_types/non_func_test/#tools","text":"Jmeter Loadrunner Webserver Stress tool","title":"Tools"},{"location":"istqb_material/test_types/test_classification/","text":"ISTQB Syllabus classification: Other classification","title":"Classification"},{"location":"istqb_material/test_types/test_classification/#istqb-syllabus-classification","text":"Other classification","title":"ISTQB Syllabus classification:"},{"location":"istqb_material/test_types/white_box/","text":"is a method of software testing that tests internal structures or workings of an application is a method of software testing that tests internal structures or workings of an application Types of White Box Testing White box testing can take several forms: Unit testing \u2014 test the code that each component is working as expected. Mutation testing \u2014 a type of unit testing that checks the robustness and consistency of the code by defining tests, making small, random changes to the code and seeing if the tests still pass. Integration testing \u2014 tests specifically designed to check integration points between internal components in a software system, or integrations with external systems. White box penetration testing \u2014 an ethical hacker acts as a knowledgeable insider, attempting to attack an application based on intimate knowledge of its code and environment. Static code analysis \u2014 automatically identifying vulnerabilities or coding errors in static code, using predefined patterns or machine learning analysis.","title":"White Box"},{"location":"istqb_material/test_types/white_box/#types-of-white-box-testing","text":"White box testing can take several forms: Unit testing \u2014 test the code that each component is working as expected. Mutation testing \u2014 a type of unit testing that checks the robustness and consistency of the code by defining tests, making small, random changes to the code and seeing if the tests still pass. Integration testing \u2014 tests specifically designed to check integration points between internal components in a software system, or integrations with external systems. White box penetration testing \u2014 an ethical hacker acts as a knowledgeable insider, attempting to attack an application based on intimate knowledge of its code and environment. Static code analysis \u2014 automatically identifying vulnerabilities or coding errors in static code, using predefined patterns or machine learning analysis.","title":"Types of White Box Testing"},{"location":"istqb_material/tool_support_test/man_vs_aut/","text":"Scenarios Manual Testing Scenarios Exploratory Testing This type of testing requires the tester\u2019s domain expertise, logical and creative thinking, past knowledge and experience. In this scenario, human skills are required to execute the testing process. Usability Testing In this testing manual approach is preferred as we need to evaluate how user-friendly, efficient and easy-to-use the application is from an end-user\u2019s perspective . Ad-hoc Testing It is a totally unplanned method of testing where the understanding and insight of the tester is the only important factor. Test Automation Scenarios Regression Testing Here, automated testing is suitable because of the frequent code changes and the ability to run the regressions in a timely manner. Load Testing Automated testing is also the best way to complete the testing efficiently when it comes to load testing. Performance Testing Testing which requires the simulation of thousands of concurrent users requires automation. This involves load, stress,volume etc.","title":"Manual vs Automation"},{"location":"istqb_material/tool_support_test/man_vs_aut/#scenarios","text":"","title":"Scenarios"},{"location":"istqb_material/tool_support_test/man_vs_aut/#manual-testing-scenarios","text":"Exploratory Testing This type of testing requires the tester\u2019s domain expertise, logical and creative thinking, past knowledge and experience. In this scenario, human skills are required to execute the testing process. Usability Testing In this testing manual approach is preferred as we need to evaluate how user-friendly, efficient and easy-to-use the application is from an end-user\u2019s perspective . Ad-hoc Testing It is a totally unplanned method of testing where the understanding and insight of the tester is the only important factor.","title":"Manual Testing Scenarios"},{"location":"istqb_material/tool_support_test/man_vs_aut/#test-automation-scenarios","text":"Regression Testing Here, automated testing is suitable because of the frequent code changes and the ability to run the regressions in a timely manner. Load Testing Automated testing is also the best way to complete the testing efficiently when it comes to load testing. Performance Testing Testing which requires the simulation of thousands of concurrent users requires automation. This involves load, stress,volume etc.","title":"Test Automation Scenarios"},{"location":"istqb_material/tool_support_test/test_tool_clas/","text":"Type of testing tools: Open-source: Appium Selenium Capybara testNG Katalon Studio Cypress testNG Jmeter Commercial tools IBM Rational Functional Tester (RFT) Automation Anywhere Custom tools The framework you create.","title":"Classification"},{"location":"istqb_material/tool_support_test/test_tool_clas/#type-of-testing-tools","text":"","title":"Type of testing tools:"},{"location":"istqb_material/tool_support_test/test_tool_clas/#open-source","text":"Appium Selenium Capybara testNG Katalon Studio Cypress testNG Jmeter","title":"Open-source:"},{"location":"istqb_material/tool_support_test/test_tool_clas/#commercial-tools","text":"IBM Rational Functional Tester (RFT) Automation Anywhere","title":"Commercial tools"},{"location":"istqb_material/tool_support_test/test_tool_clas/#custom-tools","text":"The framework you create.","title":"Custom tools"},{"location":"istqb_material/tool_support_test/tool_selection/","text":"Considerations According to test experts, these are the things you need to consider when choosing your tools: 1.- Does your team possess the necessary skills to best utilize the tool? 2.- What is your team budget? 3.- What features to look for? Supported platforms Programming languages CI/CD integration capabilities Reporting functionality Complexity Cross-browser testing 4.- How difficult is script maintenance and reusability? 5.- How are the integration capabilities 6.- How and where can you get technical support?","title":"Tool selection"},{"location":"istqb_material/tool_support_test/tool_selection/#considerations","text":"According to test experts, these are the things you need to consider when choosing your tools: 1.- Does your team possess the necessary skills to best utilize the tool? 2.- What is your team budget? 3.- What features to look for? Supported platforms Programming languages CI/CD integration capabilities Reporting functionality Complexity Cross-browser testing 4.- How difficult is script maintenance and reusability? 5.- How are the integration capabilities 6.- How and where can you get technical support?","title":"Considerations"}]}